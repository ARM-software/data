{
    "_type": "Events",
    "timestamp": "Thu Feb  8 21:07:04 2024",
    "implementer": "A",
    "cpuid": "0x41d80",
    "cpu": "Cortex-A520",
    "architecture": "armv9.2-a",
    "pmu_architecture": "pmuv3",
    "refs": [
        {
            "ref": "Cortex-A520 TRM",
            "public": true
        }
    ],
    "events": [
        {
            "code": 0,
            "refs": [
                0
            ],
            "name": "SW_INCR",
            "architectural": true,
            "type": "INS",
            "description": "Instruction architecturally executed, Condition code check pass, software increment The counter counts each write to the AArch64-PMSWINC_EL0 register, for each implemented event counter <n>: If AArch64-PMEVTYPER<n>_EL0.evtCount is 0x0000 then the counter counts each MSR write to AArch64-PMSWINC_EL0 with bit [n] set to 1. If the PE performs two architecturally executed writes to the AArch64-PMSWINC_EL0 register without an intervening Context Synchronization Event, then the counter is incremented twice"
        },
        {
            "code": 1,
            "refs": [
                0
            ],
            "name": "L1I_CACHE_REFILL",
            "architectural": false,
            "type": "UEVT",
            "subtype": "REFILL",
            "component": "L1I",
            "description": "Level 1 instruction cache refill This event counts any instruction fetch which misses in the cache. The following instructions are not counted: - Cache maintenance instructions - Non-cacheable accesses"
        },
        {
            "code": 2,
            "refs": [
                0
            ],
            "name": "L1I_TLB_REFILL",
            "architectural": false,
            "type": "UEVT",
            "component": "L1ITLB",
            "description": "Level 1 instruction TLB refill This event counts any refill of the instruction L1 TLB from the L2 TLB, including refills that result in a translation fault. The following instructions are not counted: - TLB maintenance instructions This event counts regardless of whether the Memory Management Unit (MMU) is enabled"
        },
        {
            "code": 3,
            "refs": [
                0
            ],
            "name": "L1D_CACHE_REFILL",
            "architectural": false,
            "type": "UEVT",
            "subtype": "WRITE",
            "component": "L1D",
            "description": "Level 1 data cache refill This event counts any load or store operation or translation table walk that causes data to be read from outside the L1 cache, including accesses which do not allocate into the L1 cache. The following instructions are not counted: - Cache maintenance instructions and prefetches - Stores of an entire cache line, even if they make a coherency request outside the L1 cache - Partial cache line writes which do not allocate into the L1 cache - Non-cacheable accesses This event counts the sum of L1D_CACHE_REFILL_RD and L1D_CACHE_REFILL_WR"
        },
        {
            "code": 4,
            "refs": [
                0
            ],
            "name": "L1D_CACHE",
            "architectural": false,
            "type": "UEVT",
            "subtype": "REFILL",
            "component": "L1D",
            "description": "Level 1 data cache access This event counts any load or store operation or translation table walk that looks up in the L1 data cache. In particular, any access that could count the L1D_CACHE_REFILL event causes this event to count. The following instructions are not counted: - Cache maintenance instructions and prefetches - Non-cacheable accesses This event counts the sum of L1D_CACHE_RD and L1D_CACHE_WR"
        },
        {
            "code": 5,
            "refs": [
                0
            ],
            "name": "L1D_TLB_REFILL",
            "architectural": false,
            "type": "UEVT",
            "component": "L1DTLB",
            "description": "Level 1 data TLB refill This event counts any refill of the data L1 TLB from the L2 TLB. This includes refills which result in a translation fault. The following instructions are not counted: - TLB maintenance instructions This event counts regardless of whether the MMU is enabled"
        },
        {
            "code": 6,
            "refs": [
                0
            ],
            "name": "LD_RETIRED",
            "architectural": true,
            "type": "INS",
            "description": "Instruction architecturally executed, Condition code check pass, load This event counts all load and prefetch instructions, including the Armv8.1-A atomic instructions, other than the ST* variants"
        },
        {
            "code": 7,
            "refs": [
                0
            ],
            "name": "ST_RETIRED",
            "architectural": true,
            "type": "INS",
            "description": "Instruction architecturally executed, Condition code check pass, store This event counts all store instructions and the Data Cache Zero by Virtual Address (DC ZVA) instruction. The event includes all the Armv8.1-A atomic instructions. Store-Exclusive instructions that fail are not counted"
        },
        {
            "code": 8,
            "refs": [
                0
            ],
            "name": "INST_RETIRED",
            "architectural": true,
            "type": "INS",
            "description": "Instruction architecturally executed This event counts all retired instructions, including those that fail their condition check"
        },
        {
            "code": 9,
            "refs": [
                0
            ],
            "name": "EXC_TAKEN",
            "type": "EXC",
            "description": "Exception taken The counter counts each exception taken"
        },
        {
            "code": 10,
            "refs": [
                0
            ],
            "name": "EXC_RETURN",
            "architectural": true,
            "type": "EXC",
            "description": "Instruction architecturally executed, Condition code check pass, exception return The counter counts each architecturally-executed exception return instruction"
        },
        {
            "code": 11,
            "refs": [
                0
            ],
            "name": "CID_WRITE_RETIRED",
            "architectural": true,
            "type": "INS",
            "description": "Instruction architecturally executed, Condition code check pass, write to CONTEXTIDR This event only counts writes using the CONTEXTIDR_EL1 mnemonic. Writes to CONTEXTIDR_EL12 and CONTEXTIDR_EL2 are not counted"
        },
        {
            "code": 12,
            "refs": [
                0
            ],
            "name": "PC_WRITE_RETIRED",
            "architectural": true,
            "type": "EXC",
            "description": "Instruction architecturally executed, Condition code check pass, Software change of the PC This event counts all branches taken and popped from the branch monitor. This excludes exception entries, debug entries, and CCFAIL branches"
        },
        {
            "code": 13,
            "refs": [
                0
            ],
            "name": "BR_IMMED_RETIRED",
            "architectural": true,
            "type": "EXC",
            "description": "Branch instruction architecturally executed, immediate This event counts all branches decoded as immediate branches, taken or not, and popped from the branch monitor. This excludes exception entries, debug entries, and CCFAIL branches"
        },
        {
            "code": 14,
            "refs": [
                0
            ],
            "name": "BR_RETURN_RETIRED",
            "architectural": true,
            "type": "INS",
            "description": "Branch instruction architecturally executed, procedure return, taken"
        },
        {
            "code": 16,
            "refs": [
                0
            ],
            "name": "BR_MIS_PRED",
            "architectural": false,
            "type": "UEVT",
            "subtype": "MISPREDICT",
            "component": "BPU",
            "description": "Branch instruction speculatively executed, mispredicted or not predicted This event counts any predictable branch instruction that is mispredicted for either of the following reasons: - Dynamic misprediction - The MMU is off and the branches are statically predicted not taken"
        },
        {
            "code": 17,
            "refs": [
                0
            ],
            "name": "CPU_CYCLES",
            "architectural": false,
            "type": "CYCLE",
            "description": "Cycle The counter increments on every cycle"
        },
        {
            "code": 18,
            "refs": [
                0
            ],
            "name": "BR_PRED",
            "architectural": false,
            "type": "UEVT",
            "component": "BPU",
            "description": "Predictable branch instruction speculatively executed This event counts all predictable branches"
        },
        {
            "code": 19,
            "refs": [
                0
            ],
            "name": "MEM_ACCESS",
            "architectural": false,
            "type": "INS",
            "subtype": "ACCESS",
            "description": "Data memory access This event counts memory accesses due to load or store instructions. Memory accesses are not counted if they are caused by any of the following actions: - Instruction fetches - Cache maintenance instructions - Translation table walks or prefetches This event counts the sum of MEM_ACCESS_RD and MEM_ACCESS_WR"
        },
        {
            "code": 20,
            "refs": [
                0
            ],
            "name": "L1I_CACHE",
            "architectural": false,
            "type": "UEVT",
            "subtype": "ACCESS",
            "component": "L1I",
            "description": "Level 1 instruction cache access This event counts any instruction fetch which accesses the L1 instruction cache. The following instructions are not counted: - Cache maintenance instructions - Non-cacheable accesses"
        },
        {
            "code": 21,
            "refs": [
                0
            ],
            "name": "L1D_CACHE_WB",
            "architectural": false,
            "type": "UEVT",
            "subtype": "WRITE",
            "component": "L1D",
            "description": "Level 1 data cache write-back This event counts any write-back of data from the L1 data cache to L2 cache or L3 cache. The event counts both victim line evictions and snoops, including cache maintenance operations. The following instructions are not counted: - Invalidations which do not result in data being transferred out of the L1 cache - Full-line writes which write to L2 cache without writing L1 cache, such as writestreaming mode"
        },
        {
            "code": 22,
            "refs": [
                0
            ],
            "name": "L2D_CACHE",
            "architectural": false,
            "type": "UEVT",
            "subtype": "WRITE",
            "component": "L2",
            "description": "Level 2 data cache access If the complex is configured with a per-complex L2 cache,this event counts: - Any transaction from the L1 cache which looks up in the L2 cache - Any write-back from the L1 cache to the L2 cache Snoops from outside the core and cache maintenance operations are not counted. If the complex is not configured with a per-complex L2 cache, this event counts the cluster cache event, as defined by L3D_CACHE. If neither a per-complex cache or a cluster cache are configured, then this event is not implemented"
        },
        {
            "code": 23,
            "refs": [
                0
            ],
            "name": "L2D_CACHE_REFILL",
            "architectural": false,
            "type": "UEVT",
            "subtype": "READ",
            "component": "L2",
            "description": "Level 2 data cache refill If the complex is configured with a per-complex L2 cache, this event counts any cacheable transaction from L1 cache which causes data to be read from outside the core. L2 cache refills that are caused by stashes into L2 cache are counted. If the complex is not configured with a per-complex L2 cache, this event is not implemented"
        },
        {
            "code": 24,
            "refs": [
                0
            ],
            "name": "L2D_CACHE_WB",
            "architectural": false,
            "type": "UEVT",
            "subtype": "WRITE",
            "component": "L2",
            "description": "Level 2 data cache write-back If the complex is configured with a per-complex L2 cache, this event counts any write-back of data from the L2 cache to a location outside the complex. The event includes snoops to the L2 cache that return data, regardless of whether they cause an invalidation. Invalidations from the L2 that do not write data outside of the complex and snoops that return data from the L1 cache are not counted. If the core is not configured with a per-complex L2 cache, this event is not implemented"
        },
        {
            "code": 25,
            "refs": [
                0
            ],
            "name": "BUS_ACCESS",
            "architectural": false,
            "type": "UEVT",
            "component": "BUS",
            "description": "Bus access This event counts for every beat of data that is transferred over the data channels between the complex and the DynamIQ Shared Unit (DSU). If both read and write data beats are transferred on a given cycle, this event is counted twice on that cycle. This event counts the sum of BUS_ACCESS_RD and BUS_ACCESS_WR"
        },
        {
            "code": 26,
            "refs": [
                0
            ],
            "name": "MEMORY_ERROR",
            "type": "UEVT",
            "description": "Local memory error This event counts any correctable or uncorrectable memory error (ECC or parity) in the protected core RAMs"
        },
        {
            "code": 27,
            "refs": [
                0
            ],
            "name": "INST_SPEC",
            "architectural": false,
            "type": "INS",
            "description": "Operation speculatively executed This event counts issued instructions, including instructions that are later flushed due to mis-speculation"
        },
        {
            "code": 28,
            "refs": [
                0
            ],
            "name": "TTBR_WRITE_RETIRED",
            "architectural": true,
            "type": "INS",
            "description": "Instruction architecturally executed, Condition code check pass, write to TTBR This event only counts writes to TTBR0/TTBR1 in AArch32 and TTBR0_EL1/TTBR1_EL1 in AArch64. The following instructions are not counted: - Accesses to TTBR0_EL12/TTBR1_EL12 or TTBR0_EL2/TTBR1_EL2"
        },
        {
            "code": 29,
            "refs": [
                0
            ],
            "name": "BUS_CYCLES",
            "architectural": false,
            "type": "UEVT",
            "component": "BUS",
            "description": "Bus cycle This event duplicates CPU_CYCLES"
        },
        {
            "code": 30,
            "refs": [
                0
            ],
            "name": "CHAIN",
            "for_driver": true,
            "type": "UEVT",
            "description": "CHAIN For odd-numbered counters, this event increments the count by one for each overflow of the preceding even-numbered counter. For even-numbered counters, there is no increment. Note: This event is not exported to the trace unit"
        },
        {
            "code": 32,
            "refs": [
                0
            ],
            "name": "L2D_CACHE_ALLOCATE",
            "architectural": false,
            "type": "UEVT",
            "subtype": "WRITE",
            "component": "L2",
            "description": "Level 2 data cache allocation without refill If the complex is configured with a per-complex L2 cache, this event counts any full cache line write into the L2 cache that does not cause a linefill. The event includes write-backs from L1 to L2 and full-line writes that do not allocate into the L1 cache. If the complex is not configured with a per-complex L2 cache, this event is not implemented"
        },
        {
            "code": 33,
            "refs": [
                0
            ],
            "name": "BR_RETIRED",
            "architectural": true,
            "type": "INS",
            "description": "Instruction architecturally executed, branch Counts all branch instructions, memory-reading and data-processing instructions that explicitly write to the PC, at retirement"
        },
        {
            "code": 34,
            "refs": [
                0
            ],
            "name": "BR_MIS_PRED_RETIRED",
            "architectural": false,
            "type": "UEVT",
            "subtype": "MISPREDICT",
            "component": "BPU",
            "description": "Branch instruction architecturally executed, mispredicted The counter counts all instructions counted by BR_RETIRED that were not correctly predicted"
        },
        {
            "code": 35,
            "refs": [
                0
            ],
            "name": "STALL_FRONTEND",
            "architectural": false,
            "type": "CYCLE",
            "description": "No operation sent for execution due to the frontend The counter counts on any cycle when no operations are issued due to the instruction queue being empty"
        },
        {
            "code": 36,
            "refs": [
                0
            ],
            "name": "STALL_BACKEND",
            "architectural": false,
            "type": "CYCLE",
            "description": "No operation sent for execution due to the backend The counter counts on any cycle when no operations are issued due to a pipeline stall"
        },
        {
            "code": 37,
            "refs": [
                0
            ],
            "name": "L1D_TLB",
            "architectural": false,
            "type": "UEVT",
            "component": "L1DTLB",
            "description": "Level 1 data TLB access This event counts any load or store operation which accesses the L1 data TLB. If both a load and a store are executed on a cycle, this event counts twice. This event counts regardless of whether the MMU is enabled"
        },
        {
            "code": 38,
            "refs": [
                0
            ],
            "name": "L1I_TLB",
            "architectural": false,
            "type": "UEVT",
            "component": "L1ITLB",
            "description": "Level 1 instruction TLB access This event counts any instruction fetch which accesses the instruction L1 TLB. This event counts regardless of whether the MMU is enabled"
        },
        {
            "code": 43,
            "refs": [
                0
            ],
            "name": "L3D_CACHE",
            "architectural": false,
            "type": "UEVT",
            "subtype": "WRITE",
            "component": "L3",
            "description": "Level 3 data cache access If the complex is configured with a per-complex L2 cache and the cluster is configured with an L3 cache, this event counts for any cacheable read transaction returning data from the DSU, or for any cacheable write to the DSU. If either the complex is configured without a per-complex L2 or the cluster is configured without an L3 cache, this event is not implemented"
        },
        {
            "code": 45,
            "refs": [
                0
            ],
            "name": "L2D_TLB_REFILL",
            "architectural": false,
            "type": "UEVT",
            "component": "L2TLB",
            "description": "Level 2 data TLB refill This event counts on any refill of the L2 TLB, caused by either an instruction or data access. This event does not count if the MMU is disabled"
        },
        {
            "code": 47,
            "refs": [
                0
            ],
            "name": "L2D_TLB",
            "architectural": false,
            "type": "UEVT",
            "component": "L2TLB",
            "description": "Level 2 data TLB access Attributable Level 2 unified TLB access. This event counts on any access to the L2 TLB that is caused by a refill of any of the L1 TLBs. This event does not count if the MMU is disabled"
        },
        {
            "code": 52,
            "refs": [
                0
            ],
            "name": "DTLB_WALK",
            "architectural": false,
            "type": "UEVT",
            "component": "L2TLB",
            "description": "Data TLB access with at least one translation table walk This event counts on any data access which causes L2D_TLB_REFILL to count"
        },
        {
            "code": 53,
            "refs": [
                0
            ],
            "name": "ITLB_WALK",
            "architectural": false,
            "type": "UEVT",
            "component": "L2TLB",
            "description": "Instruction TLB access with at least one translation table walk This event counts on any instruction access which causes L2D_TLB_REFILL to count"
        },
        {
            "code": 54,
            "refs": [
                0
            ],
            "name": "LL_CACHE_RD",
            "architectural": false,
            "type": "UEVT",
            "subtype": "READ",
            "component": "L1D",
            "description": "Last level cache access, read If IMP_CPUECTLR_EL1.EXTLLC is set, this event counts any cacheable read transaction that returns a data source of \"interconnect cache\". If IMP_CPUECTLR_EL1.EXTLLC is not set, this event is a duplicate of the L*D_CACHE_RD event corresponding to the last level of cache implemented in the cluster. That is: - L3D_CACHE_RD, if both per-complex L2 cache and cluster L3 cache are implemented - L2D_CACHE_RD, if only one of these caches are implemented - L1D_CACHE_RD if neither is implemented"
        },
        {
            "code": 55,
            "refs": [
                0
            ],
            "name": "LL_CACHE_MISS_RD",
            "architectural": false,
            "type": "UEVT",
            "subtype": "READ",
            "component": "L1D",
            "description": "Last level cache miss, read If IMP_CPUECTLR_EL1.EXTLLC is set, this event counts any cacheable read transaction that returns a data source of \"DRAM\", \"remote\", or \"inter-cluster peer\". If IMP_CPUECTLR_EL1.EXTLLC is not set, this event is a duplicate of the event that corresponds to the last level of cache implemented in the cluster. Therefore, this event is a duplicate of: - L3D_CACHE_REFILL_RD, if both per-complex L2 cache and cluster L3 cache are implemented - L2D_CACHE_REFILL_RD, if only one is implemented - L1D_CACHE_REFILL_RD, if neither is implemented"
        },
        {
            "code": 56,
            "refs": [
                0
            ],
            "name": "REMOTE_ACCESS_RD",
            "type": "UEVT",
            "description": "Access to another socket in a multi-socket system, read This event counts any read transaction that returns a data source of \"remote\""
        },
        {
            "code": 57,
            "refs": [
                0
            ],
            "name": "L1D_CACHE_LMISS_RD",
            "architectural": false,
            "type": "UEVT",
            "subtype": "READ",
            "component": "L1D",
            "description": "Level 1 data cache long-latency read miss This event counts each memory read access counted by L1D_CACHE that incurs additional latency because it returns data from outside the L1 data or unified cache of this Processing Element (PE)"
        },
        {
            "code": 58,
            "refs": [
                0
            ],
            "name": "OP_RETIRED",
            "architectural": false,
            "type": "UEVT",
            "description": "Micro-operation architecturally executed The counter counts each operation counted by OP_SPEC that would be executed in a Simple sequential execution of the program"
        },
        {
            "code": 59,
            "refs": [
                0
            ],
            "name": "OP_SPEC",
            "architectural": false,
            "type": "UEVT",
            "description": "Micro-operation speculatively executed The counter counts the number of operations executed by the PE, including those that are executed speculatively and would not be executed in a Simple sequential execution of the program"
        },
        {
            "code": 60,
            "refs": [
                0
            ],
            "name": "STALL",
            "architectural": false,
            "type": "INS",
            "description": "No operation sent for execution This event counts every Attributable cycle on which no Attributable instruction or operation was sent for execution on this PE"
        },
        {
            "code": 61,
            "refs": [
                0
            ],
            "name": "STALL_SLOT_BACKEND",
            "architectural": false,
            "type": "CYCLE",
            "description": "No operation sent for execution on a Slot due to the backend This event counts each Slot counted by STALL_SLOT where no Attributable instruction or operation was sent for execution because the backend is unable to accept one of: - The instruction operation available for the PE on the Slot - Any operations on the Slot"
        },
        {
            "code": 62,
            "refs": [
                0
            ],
            "name": "STALL_SLOT_FRONTEND",
            "architectural": false,
            "type": "CYCLE",
            "description": "No operation sent for execution on a Slot due to the frontend This event counts each Slot counted by STALL_SLOT where no Attributable instruction or operation was sent for execution because there was no Attributable instruction or operation available to issue from the PE from the frontend for the Slot"
        },
        {
            "code": 63,
            "refs": [
                0
            ],
            "name": "STALL_SLOT",
            "architectural": false,
            "type": "CYCLE",
            "description": "No operation sent for execution on a Slot This event counts on each Attributable cycle the number of instruction or operation Slots that were not occupied by an instruction or operation Attributable to the PE"
        },
        {
            "code": 64,
            "refs": [
                0
            ],
            "name": "L1D_CACHE_RD",
            "recommended": true,
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "subtype": "READ",
            "component": "L1D",
            "description": "Level 1 data cache access, read This event counts any load operation or page table walk access which looks up in the L1 data cache. In particular, any access which could count the L1D_CACHE_REFILL_RD event causes this event to count. The following instructions are not counted: - Cache maintenance instructions and prefetches - Non-cacheable accesses Note: This event is not exported to the trace unit"
        },
        {
            "code": 65,
            "refs": [
                0
            ],
            "name": "L1D_CACHE_WR",
            "recommended": true,
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "subtype": "WRITE",
            "component": "L1D",
            "description": "Level 1 data cache access, write Counts any store operation which looks up in the L1 data cache. In particular, any access which could count the L1D_CACHE_REFILL event causes this event to count. The following instructions are not counted: - Cache maintenance instructions and prefetches - Non-cacheable accesses Note: This event is not exported to the trace unit"
        },
        {
            "code": 66,
            "refs": [
                0
            ],
            "name": "L1D_CACHE_REFILL_RD",
            "recommended": true,
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "subtype": "READ",
            "component": "L1D",
            "description": "Level 1 data cache refill, read This event counts any load operation or translation table walk access which causes data to be read from outside the L1 data cache,including accesses which do not allocate into the L1 cache. The following instructions are not counted: - Cache maintenance instructions and prefetches - Non-cacheable accesses Note: This event is not exported to the trace unit"
        },
        {
            "code": 67,
            "refs": [
                0
            ],
            "name": "L1D_CACHE_REFILL_WR",
            "recommended": true,
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "subtype": "WRITE",
            "component": "L1D",
            "description": "Level 1 data cache refill, write This event counts any store operation which causes data to be read from outside the L1 data cache, including accesses which do not allocate into L1 cache. The following instructions are not counted: - Cache maintenance instructions and prefetches. - Stores of an entire cache line, even if they make a coherency request outside the L1 cache - Partial cache line writes which do not allocate into the L1 cache - Non-cacheable accesses Note: This event is not exported to the trace unit"
        },
        {
            "code": 68,
            "refs": [
                0
            ],
            "name": "L1D_CACHE_REFILL_INNER",
            "recommended": true,
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "subtype": "REFILL",
            "component": "L1D",
            "description": "Level 1 data cache refill, inner This event counts any L1 data cache linefill, as counted by L1D_CACHE_REFILL, that hits in the L2 cache, L3 cache, or another core in the cluster. Note: This event is not exported to the trace unit"
        },
        {
            "code": 69,
            "refs": [
                0
            ],
            "name": "L1D_CACHE_REFILL_OUTER",
            "recommended": true,
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "subtype": "REFILL",
            "component": "L1D",
            "description": "Level 1 data cache refill, outer This event counts any L1 data cache linefill (as counted by L1D_CACHE_REFILL) that does not hit in the L2 cache, L3 cache, or another core in the cluster, and instead obtains data from outside the cluster. Note: This event is not exported to the trace unit"
        },
        {
            "code": 80,
            "refs": [
                0
            ],
            "name": "L2D_CACHE_RD",
            "recommended": true,
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "subtype": "READ",
            "component": "L2",
            "description": "Level 2 data cache access, read If the complex is configured with a per-complex L2 cache, this event counts any read transaction from the L1 cache that looks up in the L2 cache. Snoops from outside the complex are not counted. If the complex is configured without a per-complex L2 cache, this event counts the cluster cache event, as defined by L3D_CACHE_RD. If neither a per-complex cache or a cluster cache is configured, this event is not implemented. Note: This event is not exported to the trace unit"
        },
        {
            "code": 81,
            "refs": [
                0
            ],
            "name": "L2D_CACHE_WR",
            "recommended": true,
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "subtype": "WRITE",
            "component": "L2",
            "description": "Level 2 data cache access, write If the complex is configured with a per-complex L2 cache, this event counts any write transaction from the L1 cache that looks up in the L2 cache or any write-back from L1 cache that allocates into the L2 cache. Snoops from outside the complex are not counted. If the complex is configured without a per-complex L2 cache, this event is not implemented. Note: This event is not exported to the trace unit"
        },
        {
            "code": 82,
            "refs": [
                0
            ],
            "name": "L2D_CACHE_REFILL_RD",
            "recommended": true,
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "subtype": "READ",
            "component": "L2",
            "description": "Level 2 data cache refill, read If the complex is configured with a per-complex L2 cache, this event counts any cacheable read transaction from L1 cache that causes data to be read from outside the complex. L2 cache refills caused by stashes into L2 are not counted. Transactions such as ReadUnique are counted here as read transactions, even though they can be generated by store instructions. If the complex is configured without a per-complex L2 cache, this event counts the cluster cache event, as defined by L3D_CACHE_REFILL_RD. If neither a per-complex cache or a cluster cache is configured, this event is not implemented. Note: This event is not exported to the trace unit"
        },
        {
            "code": 83,
            "refs": [
                0
            ],
            "name": "L2D_CACHE_REFILL_WR",
            "recommended": true,
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "subtype": "WRITE",
            "component": "L2",
            "description": "Level 2 data cache refill, write If the complex is configured with a per-complex L2 cache, this event counts any write transaction from L1 cache that causes data to be read from outside the complex. L2 cache refills caused by stashes into L2 are not counted. Transactions such as ReadUnique are not counted as write transactions. If the complex is configured without a per-core L2 cache, this event is not implemented. Note: This event is not exported to the trace unit"
        },
        {
            "code": 96,
            "refs": [
                0
            ],
            "name": "BUS_ACCESS_RD",
            "recommended": true,
            "impdef": true,
            "type": "UEVT",
            "component": "BUS",
            "description": "Bus access, read This event counts for every beat of data that is transferred over the read data channel between the complex and the DSU. Note: This event is not exported to the trace unit"
        },
        {
            "code": 97,
            "refs": [
                0
            ],
            "name": "BUS_ACCESS_WR",
            "recommended": true,
            "impdef": true,
            "type": "UEVT",
            "component": "BUS",
            "description": "Bus access, write This event counts for every beat of data that is transferred over the write data channel between the complex and the DSU. Note: This event is not exported to the trace unit"
        },
        {
            "code": 102,
            "refs": [
                0
            ],
            "name": "MEM_ACCESS_RD",
            "recommended": true,
            "impdef": true,
            "architectural": false,
            "type": "INS",
            "subtype": "READ",
            "description": "Data memory access, read This event counts memory accesses due to load instructions. The following instructions are not counted: - Instruction fetches - Cache maintenance instructions - Translation table walks - Prefetches Note: This event is not exported to the trace unit"
        },
        {
            "code": 103,
            "refs": [
                0
            ],
            "name": "MEM_ACCESS_WR",
            "recommended": true,
            "impdef": true,
            "architectural": false,
            "type": "INS",
            "subtype": "WRITE",
            "description": "Data memory access, write This event counts memory accesses due to store instructions. The following instructions are not counted: - Instruction fetches - Cache maintenance instructions - Translation table walks - Prefetches Note: This event is not exported to the trace unit"
        },
        {
            "code": 110,
            "refs": [
                0
            ],
            "name": "STREX_FAIL_SPEC",
            "recommended": true,
            "impdef": true,
            "architectural": false,
            "type": "INS",
            "description": "Exclusive operation speculatively executed, Store-Exclusive fail The counter counts Store-Exclusive instructions speculatively executed that fail to complete a write"
        },
        {
            "code": 111,
            "refs": [
                0
            ],
            "name": "STREX_SPEC",
            "recommended": true,
            "impdef": true,
            "architectural": false,
            "type": "INS",
            "description": "Exclusive operation speculatively executed, Store-Exclusive The counter counts Store-Exclusive instructions speculatively executed"
        },
        {
            "code": 112,
            "refs": [
                0
            ],
            "name": "LD_SPEC",
            "recommended": true,
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "description": "Operation speculatively executed, load Note: This event is not exported to the trace unit"
        },
        {
            "code": 113,
            "refs": [
                0
            ],
            "name": "ST_SPEC",
            "recommended": true,
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "description": "Operation speculatively executed, store Note: This event is not exported to the trace unit"
        },
        {
            "code": 114,
            "refs": [
                0
            ],
            "name": "LDST_SPEC",
            "recommended": true,
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "description": "Operation speculatively executed, load or store Note: This event is not exported to the trace unit"
        },
        {
            "code": 115,
            "refs": [
                0
            ],
            "name": "DP_SPEC",
            "recommended": true,
            "impdef": true,
            "architectural": false,
            "type": "INS",
            "description": "Operation speculatively executed, integer data processing This event counts retired integer data-processing instructions. Note: This event is not exported to the trace unit"
        },
        {
            "code": 116,
            "refs": [
                0
            ],
            "name": "ASE_SPEC",
            "recommended": true,
            "impdef": true,
            "architectural": false,
            "type": "INS",
            "description": "Operation speculatively executed, Advanced SIMD This event counts retired Advanced SIMD instructions. Note: This event is not exported to the trace unit"
        },
        {
            "code": 117,
            "refs": [
                0
            ],
            "name": "VFP_SPEC",
            "recommended": true,
            "impdef": true,
            "architectural": false,
            "type": "INS",
            "description": "Operation speculatively executed, scalar floating-point This event counts retired floating-point instructions. Note: This event is not exported to the trace unit"
        },
        {
            "code": 118,
            "refs": [
                0
            ],
            "name": "PC_WRITE_SPEC",
            "recommended": true,
            "impdef": true,
            "architectural": false,
            "type": "INS",
            "description": "Operation speculatively executed, Software change of the PC This event counts retired branch instructions. Note: This event is not exported to the trace unit"
        },
        {
            "code": 119,
            "refs": [
                0
            ],
            "name": "CRYPTO_SPEC",
            "recommended": true,
            "impdef": true,
            "architectural": false,
            "type": "INS",
            "description": "Operation speculatively executed, Cryptographic instruction This event counts retired Cryptographic instructions. Note: This event is not exported to the trace unit"
        },
        {
            "code": 120,
            "refs": [
                0
            ],
            "name": "BR_IMMED_SPEC",
            "recommended": true,
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "description": "Branch speculatively executed, immediate branch This event duplicates BR_IMMED_RETIRED. Note: This event is not exported to the trace unit"
        },
        {
            "code": 121,
            "refs": [
                0
            ],
            "name": "BR_RETURN_SPEC",
            "recommended": true,
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "description": "Branch speculatively executed, procedure return This event duplicates BR_RETURN_RETIRED. Note: This event is not exported to the trace unit"
        },
        {
            "code": 122,
            "refs": [
                0
            ],
            "name": "BR_INDIRECT_SPEC",
            "recommended": true,
            "impdef": true,
            "architectural": false,
            "type": "EXC",
            "description": "Branch speculatively executed, indirect branch The counter counts indirect branch instructions speculatively executed. This includes software change of the PC other than exception-generating instructions and immediate branch instructions. Note: This event is not exported to the trace unit"
        },
        {
            "code": 134,
            "refs": [
                0
            ],
            "name": "EXC_IRQ",
            "recommended": true,
            "impdef": true,
            "type": "EXC",
            "description": "Exception taken, IRQ Note: This event is not exported to the trace unit"
        },
        {
            "code": 135,
            "refs": [
                0
            ],
            "name": "EXC_FIQ",
            "recommended": true,
            "impdef": true,
            "type": "EXC",
            "description": "Exception taken, FIQ Note: This event is not exported to the trace unit"
        },
        {
            "code": 160,
            "refs": [
                0
            ],
            "name": "L3D_CACHE_RD",
            "recommended": true,
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "subtype": "READ",
            "component": "L3",
            "description": "Level 3 data cache access, read This event counts for any cacheable read transaction returning data from the DSU. If either the complex is configured without a per-complex L2 cache or the cluster is configured without an L3 cache, this event is not implemented. Note: This event is not exported to the trace unit"
        },
        {
            "code": 162,
            "refs": [
                0
            ],
            "name": "L3D_CACHE_REFILL_RD",
            "recommended": true,
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "subtype": "READ",
            "component": "L3",
            "description": "Level 3 data cache refill, read If either the complex is configured without a per-complex L2 cache or the cluster is configured without an L3 cache, this event is not implemented. Note: This event is not exported to the trace unit"
        },
        {
            "code": 195,
            "refs": [
                0
            ],
            "name": "L2D_WS_MODE",
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "subtype": "WRITE",
            "component": "L2",
            "description": "L2 cache write streaming mode If the complex is configured with a per-complex L2 cache, this event counts for each cycle where the core is in write streaming mode and is not allocating writes into the L2 cache. If the complex is configured without a per-complex L2 cache, this event counts the cluster cache event, as defined by L3D_WS_MODE. If neither a per-complex cache or a cluster cache is configured, this event is not implemented. Note: This event is not exported to the trace unit"
        },
        {
            "code": 196,
            "refs": [
                0
            ],
            "name": "L1D_WS_MODE_ENTRY",
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "subtype": "WRITE",
            "component": "L1D",
            "description": "L1 data cache entering write streaming mode This event counts for each entry into write streaming mode. Note: This event is not exported to the trace unit"
        },
        {
            "code": 197,
            "refs": [
                0
            ],
            "name": "L1D_WS_MODE",
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "subtype": "WRITE",
            "component": "L1D",
            "description": "L1 data cache write streaming mode This event counts for each cycle where the core is in write streaming mode and is not allocating writes into the L1 data cache. Note: This event is not exported to the trace unit"
        },
        {
            "code": 199,
            "refs": [
                0
            ],
            "name": "L3D_WS_MODE",
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "subtype": "WRITE",
            "component": "L3",
            "description": "L3 cache write streaming mode This event counts for each cycle where the core is in write streaming mode and is not allocating writes into the L3 cache. If either the complex is configured without a percomplex L2 cache or the cluster is configured without an L3 cache, this event is not implemented. Note: This event is not exported to the trace unit"
        },
        {
            "code": 200,
            "refs": [
                0
            ],
            "name": "LL_WS_MODE",
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "subtype": "WRITE",
            "component": "L1D",
            "description": "Last level cache write streaming mode If IMP_CPUECTLR_EL1.EXTLLC is set, this event counts for each cycle where the core is in write streaming mode and is not allocating writes into the system cache. - L3D_WS_MODE, if both per-complex L2 cache and cluster L3 cache are implemented - L2D_WS_MODE, if only one of these caches are implemented - L1D_WS_MODE if neither is implemented. Note: This event is not exported to the trace unit"
        },
        {
            "code": 208,
            "refs": [
                0
            ],
            "name": "L2D_WALK_TLB",
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "subtype": "ACCESS",
            "component": "L2TLB",
            "description": "L2 TLB walk cache access This event does not count if the MMU is disabled. Note: This event is not exported to the trace unit"
        },
        {
            "code": 209,
            "refs": [
                0
            ],
            "name": "L2D_WALK_TLB_REFILL",
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "subtype": "REFILL",
            "component": "L2TLB",
            "description": "L2 TLB walk cache refill This event does not count if the MMU is disabled. Note: This event is not exported to the trace unit"
        },
        {
            "code": 212,
            "refs": [
                0
            ],
            "name": "L2D_S2_TLB",
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "subtype": "ACCESS",
            "component": "L2TLB",
            "description": "L2 TLB IPA cache access This event counts on each access to the IPA cache. If a single translation table walk needs to make multiple accesses to the IPA cache, each access is counted. If stage 2 translation is disabled, this event does not count. Note: This event is not exported to the trace unit"
        },
        {
            "code": 213,
            "refs": [
                0
            ],
            "name": "L2D_S2_TLB_REFILL",
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "subtype": "REFILL",
            "component": "L2TLB",
            "description": "L2 TLB IPA cache refill This event counts on each refill of the IPA cache. If a single translation table walk needs to make multiple accesses to the IPA cache, each access that causes a refill is counted. If stage 2 translation is disabled, this event does not count. Note: This event is not exported to the trace unit"
        },
        {
            "code": 214,
            "refs": [
                0
            ],
            "name": "L2D_CACHE_STASH_DROPPED",
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "component": "L2",
            "description": "L2 cache stash dropped This event counts on each stash request that is received from the interconnect or the Accelerator Coherency Port (ACP), that targets L2 and is dropped due to lack of buffer space to hold the request. If the core is not configured with a per-complex L2 cache, this event is not implemented. Note: This event is not exported to the trace unit"
        },
        {
            "code": 215,
            "refs": [
                0
            ],
            "name": "L1D_TLB_REFILL_ETS",
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "component": "L1DTLB",
            "description": "L1D TLB refill due to ETS replay This event counts any refill counted by L1D_TLB_REFILL due to ETS replay. Note: This event is not exported to the trace unit"
        },
        {
            "code": 218,
            "refs": [
                0
            ],
            "name": "L2D_CACHE_REFILL_HWPRF_SPATIAL",
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "subtype": "REFILL",
            "component": "L2",
            "description": "L2 cache refill due to L2 spatial prefetcher This event counts any refill counted by L2D_CACHE_REFILL_HWPRF caused by L2 spatial prefetcher. Note: This event is not exported to the trace unit"
        },
        {
            "code": 219,
            "refs": [
                0
            ],
            "name": "L2D_CACHE_REFILL_HWPRF_OFFSET",
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "subtype": "REFILL",
            "component": "L2",
            "description": "L2 cache refill due to L2 offset prefetcher This event counts any refill counted by L2D_CACHE_REFILL_HWPRF caused by L2 offset prefetcher. Note: This event is not exported to the trace unit"
        },
        {
            "code": 220,
            "refs": [
                0
            ],
            "name": "L2D_CACHE_REFILL_HWPRF_PATTERN",
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "subtype": "REFILL",
            "component": "L2",
            "description": "L2 cache refill due to L2 pattern prefetcher This event counts any refill counted by L2D_CACHE_REFILL_HWPRF caused by the L2 pattern prefetcher. Note: This event is not exported to the trace unit"
        },
        {
            "code": 221,
            "refs": [
                0
            ],
            "name": "L2D_CACHE_REFILL_HWPRF_TLBD",
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "subtype": "REFILL",
            "component": "L2TLB",
            "description": "L2 cache refill due to L2 TLB prefetcher This event counts any refill counted by L2D_CACHE_REFILL_HWPRF caused by the L2 TLB prefetcher. Note: This event is not exported to the trace unit"
        },
        {
            "code": 222,
            "refs": [
                0
            ],
            "name": "L3D_CACHE_HWPRF_STRIDE",
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "subtype": "ACCESS",
            "component": "L3",
            "description": "L3 cache access due to L3 stride prefetcher This event counts any access counted by L3D_CACHE_HWPRF caused by the L3 stride prefetcher. Note: This event is not exported to the trace unit"
        },
        {
            "code": 223,
            "refs": [
                0
            ],
            "name": "L3D_CACHE_HWPRF_OFFSET",
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "subtype": "ACCESS",
            "component": "L3",
            "description": "L3 cache access due to L3 offset prefetcher This event counts any access counted by L3D_CACHE_HWPRF caused by the L3 offset prefetcher. Note: This event is not exported to the trace unit"
        },
        {
            "code": 229,
            "refs": [
                0
            ],
            "name": "STALL_BACKEND_ILOCK_ADDR",
            "impdef": true,
            "architectural": false,
            "type": "CYCLE",
            "description": "No operation issued due to the backend, input dependency, address This event counts every cycle counted by STALL_BACKEND_ILOCK, where there is an input dependency on an address operand. This type of interlock is caused by a load/store instruction waiting for data to calculate the address. Note: This event is not exported to the trace unit"
        },
        {
            "code": 230,
            "refs": [
                0
            ],
            "name": "STALL_BACKEND_ILOCK_VPU",
            "impdef": true,
            "architectural": false,
            "type": "CYCLE",
            "description": "No operation issued due to the backend, input dependency, Vector Processing Unit (VPU). This event counts every cycle counted by STALL_BACKEND_ILOCK, where there is an input dependency on a vector or predicate register. Note: This event is not exported to the trace unit"
        },
        {
            "code": 237,
            "refs": [
                0
            ],
            "name": "STALL_BACKEND_BUSY_VPU_HAZARD",
            "impdef": true,
            "architectural": false,
            "type": "CYCLE",
            "description": "No operation issued due to the backend, VPU hazard. This event counts cycles where the core stalls due to contention for the VPU with the other core. Note: This event is not exported to the trace unit"
        },
        {
            "code": 238,
            "refs": [
                0
            ],
            "name": "STALL_SLOT_BACKEND_ILOCK",
            "impdef": true,
            "architectural": false,
            "type": "CYCLE",
            "description": "No operation sent for execution on a Slot due to the backend, input dependency For each cycle, this event counts each dispatch slot that does not issue due to an interlock. Note: This event is not exported to the trace unit"
        },
        {
            "code": 240,
            "refs": [
                0
            ],
            "name": "INST_SPEC_LDST_NUKE",
            "impdef": true,
            "type": "INS",
            "description": "Instruction re-executed, read-after-read hazard This event counts each instruction which re-executes due to read-after-read hazard Note: This event is not exported to the trace unit"
        },
        {
            "code": 16389,
            "refs": [
                0
            ],
            "name": "STALL_BACKEND_MEM",
            "architectural": false,
            "type": "CYCLE",
            "subtype": "ACCESS",
            "component": "L1D",
            "description": "Memory stall cycles The counter counts each cycle counted by STALL_BACKEND_MEMBOUND where there is a demand data miss in the last level of cache within the PE clock domain or a noncacheable data access in progress. If the complex is configured with a per-complex L2 cache, this event is based on L2 cache misses. If the complex is not configured with a per-complex L2 cache, this event is based on L1 data cache misses"
        },
        {
            "code": 16390,
            "refs": [
                0
            ],
            "name": "L1I_CACHE_LMISS",
            "architectural": false,
            "type": "UEVT",
            "subtype": "ACCESS",
            "component": "L1I",
            "description": "Level 1 instruction cache long-latency miss The counter counts each access counted by L1I_CACHE that incurs additional latency because it returns instructions from outside the L1 instruction cache"
        },
        {
            "code": 16393,
            "refs": [
                0
            ],
            "name": "L2D_CACHE_LMISS_RD",
            "architectural": false,
            "type": "UEVT",
            "subtype": "READ",
            "component": "L2",
            "description": "Level 2 data cache long-latency read miss If the complex is not configured with a per-complex L2 cache, this event counts the cluster cache event, as defined by L3D_CACHE_LMISS_RD. If neither a per-complex cache or a cluster cache are configured, then this event is not implemented"
        },
        {
            "code": 16395,
            "refs": [
                0
            ],
            "name": "L3D_CACHE_LMISS_RD",
            "architectural": false,
            "type": "UEVT",
            "subtype": "READ",
            "component": "L3",
            "description": "Level 3 data cache long-latency read miss If either the complex is configured without a per-complex L2 or the cluster is configured without an L3 cache, this event is not implemented"
        },
        {
            "code": 16396,
            "refs": [
                0
            ],
            "name": "TRB_WRAP",
            "type": "UEVT",
            "description": "Trace buffer current write pointer wrapped The event is generated each time the current write pointer is wrapped to the base pointer"
        },
        {
            "code": 16397,
            "refs": [
                0
            ],
            "name": "PMU_OVFS",
            "type": "CYCLE",
            "description": "PMU overflow, counters accessible to EL1 and EL0 This event is generated each time an event causes a PMEVCTNR<n>_EL1 counter overflow when PMINTENSET_EL1[n] is set to 1, for each implemented PMU counter n in the range 0 <= n <UInt(MDCR_EL2.HPMN), and the Cycle Counter (n = 31) Note: This event is exported to the trace unit, but cannot be counted in the PMU"
        },
        {
            "code": 16398,
            "refs": [
                0
            ],
            "name": "TRB_TRIG",
            "type": "UEVT",
            "description": "Trace buffer Trigger Event The event is generated when a Trace Buffer Extension Trigger Event occurs"
        },
        {
            "code": 16399,
            "refs": [
                0
            ],
            "name": "PMU_HOVFS",
            "type": "UEVT",
            "description": "PMU overflow, counters reserved for use by EL2 The event is generated each time an event causes a PMEVCTNR<n>_EL1 counter overflow when PMINTENSET_EL1[n] is set to 1, for each implemented PMU counter n in the range UInt(MDCR_EL2.HPMN) <= n <UInt(PMCR_EL0.N). The event is not transmitted to a PE Trace Unit while TRCFR_EL2.E2TRE == 0b0. Note: This event is exported to the trace unit, but cannot be counted in the PMU"
        },
        {
            "code": 16400,
            "refs": [
                0
            ],
            "name": "TRCEXTOUT0",
            "type": "UEVT",
            "description": "Trace unit external output 0 The event is generated each time an event is signaled by ETE external event 0. Note: This event is not exported to the trace unit"
        },
        {
            "code": 16401,
            "refs": [
                0
            ],
            "name": "TRCEXTOUT1",
            "type": "UEVT",
            "description": "Trace unit external output 1 The event is generated each time an event is signaled by ETE external event 1. Note: This event is not exported to the trace unit"
        },
        {
            "code": 16402,
            "refs": [
                0
            ],
            "name": "TRCEXTOUT2",
            "type": "UEVT",
            "description": "Trace unit external output 2 The event is generated each time an event is signaled by ETE external event 2. Note: This event is not exported to the trace unit"
        },
        {
            "code": 16403,
            "refs": [
                0
            ],
            "name": "TRCEXTOUT3",
            "type": "UEVT",
            "description": "Trace unit external output 3 The event is generated each time an event is signaled by ETE external event 3. Note: This event is not exported to the trace unit"
        },
        {
            "code": 16408,
            "refs": [
                0
            ],
            "name": "CTI_TRIGOUT4",
            "type": "UEVT",
            "description": "Cross-trigger Interface output trigger 4 The event is generated each time an event is signaled on CTI output trigger 4"
        },
        {
            "code": 16409,
            "refs": [
                0
            ],
            "name": "CTI_TRIGOUT5",
            "type": "UEVT",
            "description": "Cross-trigger Interface output trigger 5 The event is generated each time an event is signaled on CTI output trigger 5"
        },
        {
            "code": 16410,
            "refs": [
                0
            ],
            "name": "CTI_TRIGOUT6",
            "type": "UEVT",
            "description": "Cross-trigger Interface output trigger 6 The event is generated each time an event is signaled on CTI output trigger 6"
        },
        {
            "code": 16411,
            "refs": [
                0
            ],
            "name": "CTI_TRIGOUT7",
            "type": "UEVT",
            "description": "Cross-trigger Interface output trigger 7 The event is generated each time an event is signaled on CTI output trigger 7"
        },
        {
            "code": 16416,
            "refs": [
                0
            ],
            "name": "LDST_ALIGN_LAT",
            "type": "UEVT",
            "description": "Access with additional latency from alignment The counter counts each access counted by MEM_ACCESS that, due to the alignment of the address and size of data being accessed, incurred additional latency"
        },
        {
            "code": 16417,
            "refs": [
                0
            ],
            "name": "LD_ALIGN_LAT",
            "type": "UEVT",
            "description": "Load with additional latency from alignment The counter counts each Memory-read operation counted by LDST_ALIGN_LAT"
        },
        {
            "code": 16418,
            "refs": [
                0
            ],
            "name": "ST_ALIGN_LAT",
            "type": "UEVT",
            "description": "Store with additional latency from alignment The counter counts each Memory-write operation counted by LDST_ALIGN_LAT"
        },
        {
            "code": 16420,
            "refs": [
                0
            ],
            "name": "MEM_ACCESS_CHECKED",
            "type": "UEVT",
            "description": "Checked data memory access The counter counts each memory access counted by MEM_ACCESS that is checked by the Memory Tagging Extension (MTE)"
        },
        {
            "code": 16421,
            "refs": [
                0
            ],
            "trm_name": "MEM_ACCESS_RD_CHECKED",
            "name": "MEM_ACCESS_CHECKED_RD",
            "type": "UEVT",
            "description": "Checked data memory access, read The counter counts each Memory-read operation counted by MEM_ACCESS_CHECKED"
        },
        {
            "code": 16422,
            "refs": [
                0
            ],
            "trm_name": "MEM_ACCESS_WR_CHECKED",
            "name": "MEM_ACCESS_CHECKED_WR",
            "type": "UEVT",
            "description": "Checked data memory access, write The counter counts each Memory-write operation counted by MEM_ACCESS_CHECKED"
        },
        {
            "code": 32770,
            "refs": [
                0
            ],
            "name": "SVE_INST_RETIRED",
            "architectural": true,
            "type": "INS",
            "description": "Instruction architecturally executed, SVE The counter counts architecturally executed SVE instructions"
        },
        {
            "code": 32774,
            "refs": [
                0
            ],
            "name": "SVE_INST_SPEC",
            "architectural": false,
            "type": "INS",
            "description": "Operation speculatively executed, SVE, including load and store The counter counts speculatively executed operations due to SVE instructions"
        },
        {
            "code": 32788,
            "refs": [
                0
            ],
            "name": "FP_HP_SPEC",
            "architectural": false,
            "type": "UEVT",
            "description": "Floating-point operation speculatively executed, half precision"
        },
        {
            "code": 32792,
            "refs": [
                0
            ],
            "name": "FP_SP_SPEC",
            "architectural": false,
            "type": "UEVT",
            "description": "Floating-point operation speculatively executed, single precision"
        },
        {
            "code": 32796,
            "refs": [
                0
            ],
            "name": "FP_DP_SPEC",
            "architectural": false,
            "type": "UEVT",
            "description": "Floating-point operation speculatively executed, double precision"
        },
        {
            "code": 32995,
            "refs": [
                0
            ],
            "name": "ASE_SVE_INT8_SPEC",
            "architectural": false,
            "type": "UEVT",
            "description": "Integer operation speculatively executed, Advanced SIMD or SVE 8-bit"
        },
        {
            "code": 32999,
            "refs": [
                0
            ],
            "name": "ASE_SVE_INT16_SPEC",
            "architectural": false,
            "type": "UEVT",
            "description": "Integer operation speculatively executed, Advanced SIMD or SVE 16-bit"
        },
        {
            "code": 33003,
            "refs": [
                0
            ],
            "name": "ASE_SVE_INT32_SPEC",
            "architectural": false,
            "type": "UEVT",
            "description": "Integer operation speculatively executed, Advanced SIMD or SVE 32-bit"
        },
        {
            "code": 33007,
            "refs": [
                0
            ],
            "name": "ASE_SVE_INT64_SPEC",
            "architectural": false,
            "type": "UEVT",
            "description": "Integer operation speculatively executed, Advanced SIMD or SVE 64-bit"
        },
        {
            "code": 33036,
            "refs": [
                0
            ],
            "name": "BR_INDNR_TAKEN_RETIRED",
            "architectural": true,
            "type": "INS",
            "description": "Branch instruction architecturally executed, indirect excluding procedure return, taken"
        },
        {
            "code": 33040,
            "refs": [
                0
            ],
            "name": "BR_IMMED_PRED_RETIRED",
            "type": "UEVT",
            "component": "BPU",
            "description": "Branch instruction architecturally executed, predicted immediate"
        },
        {
            "code": 33041,
            "refs": [
                0
            ],
            "name": "BR_IMMED_MIS_PRED_RETIRED",
            "architectural": false,
            "type": "UEVT",
            "subtype": "MISPREDICT",
            "component": "BPU",
            "description": "Branch instruction architecturally executed, mispredicted immediate"
        },
        {
            "code": 33044,
            "refs": [
                0
            ],
            "name": "BR_RETURN_PRED_RETIRED",
            "type": "UEVT",
            "component": "BPU",
            "description": "Branch instruction architecturally executed, predicted procedure return"
        },
        {
            "code": 33045,
            "refs": [
                0
            ],
            "name": "BR_RETURN_MIS_PRED_RETIRED",
            "architectural": false,
            "type": "UEVT",
            "subtype": "MISPREDICT",
            "component": "BPU",
            "description": "Branch instruction architecturally executed, mispredicted procedure return"
        },
        {
            "code": 33046,
            "refs": [
                0
            ],
            "name": "BR_INDNR_PRED_RETIRED",
            "type": "UEVT",
            "component": "BPU",
            "description": "Branch instruction architecturally executed, predicted indirect excluding procedure return"
        },
        {
            "code": 33047,
            "refs": [
                0
            ],
            "name": "BR_INDNR_MIS_PRED_RETIRED",
            "architectural": false,
            "type": "UEVT",
            "subtype": "MISPREDICT",
            "component": "BPU",
            "description": "Branch instruction architecturally executed, mispredicted indirect excluding procedure return"
        },
        {
            "code": 33052,
            "refs": [
                0
            ],
            "name": "BR_PRED_RETIRED",
            "type": "UEVT",
            "component": "BPU",
            "description": "Branch instruction architecturally executed, predicted branch"
        },
        {
            "code": 33053,
            "refs": [
                0
            ],
            "name": "BR_IND_RETIRED",
            "architectural": true,
            "type": "INS",
            "description": "Instruction architecturally executed, indirect branch"
        },
        {
            "code": 33056,
            "refs": [
                0
            ],
            "name": "INST_FETCH_PERCYC",
            "type": "UEVT",
            "description": "Event in progress, INST_FETCH"
        },
        {
            "code": 33057,
            "refs": [
                0
            ],
            "name": "MEM_ACCESS_RD_PERCYC",
            "type": "UEVT",
            "description": "Event in progress, MEM_ACCESS_RD"
        },
        {
            "code": 33060,
            "refs": [
                0
            ],
            "name": "INST_FETCH",
            "type": "INS",
            "description": "Instruction memory access"
        },
        {
            "code": 33061,
            "refs": [
                0
            ],
            "name": "BUS_REQ_RD_PERCYC",
            "impdef": true,
            "type": "UEVT",
            "component": "BUS",
            "description": "Bus read transactions in progress"
        },
        {
            "code": 33064,
            "refs": [
                0
            ],
            "name": "DTLB_WALK_PERCYC",
            "architectural": false,
            "type": "UEVT",
            "description": "Event in progress, DTLB_WALK"
        },
        {
            "code": 33065,
            "refs": [
                0
            ],
            "name": "ITLB_WALK_PERCYC",
            "architectural": false,
            "type": "UEVT",
            "description": "Event in progress, ITLB_WALK"
        },
        {
            "code": 33076,
            "refs": [
                0
            ],
            "name": "DTLB_HWUPD",
            "architectural": false,
            "type": "UEVT",
            "description": "Data TLB hardware update of translation table"
        },
        {
            "code": 33077,
            "refs": [
                0
            ],
            "name": "ITLB_HWUPD",
            "architectural": false,
            "type": "INS",
            "description": "Instruction TLB hardware update of translation table"
        },
        {
            "code": 33078,
            "refs": [
                0
            ],
            "name": "DTLB_STEP",
            "architectural": false,
            "type": "UEVT",
            "description": "Data TLB translation table walk, step"
        },
        {
            "code": 33079,
            "refs": [
                0
            ],
            "name": "ITLB_STEP",
            "architectural": false,
            "type": "INS",
            "description": "Instruction TLB translation table walk, step"
        },
        {
            "code": 33080,
            "refs": [
                0
            ],
            "name": "DTLB_WALK_LARGE",
            "architectural": false,
            "type": "UEVT",
            "description": "Data TLB large page translation table walk Large page is defined as greater than 64KB"
        },
        {
            "code": 33081,
            "refs": [
                0
            ],
            "name": "ITLB_WALK_LARGE",
            "architectural": false,
            "type": "INS",
            "description": "Instruction TLB large page translation table walk Large page is defined as greater than 64KB"
        },
        {
            "code": 33082,
            "refs": [
                0
            ],
            "name": "DTLB_WALK_SMALL",
            "architectural": false,
            "type": "UEVT",
            "description": "Data TLB small page translation table walk Small page is defined as less than or equal to 64KB"
        },
        {
            "code": 33083,
            "refs": [
                0
            ],
            "name": "ITLB_WALK_SMALL",
            "architectural": false,
            "type": "INS",
            "description": "Instruction TLB small page translation table walk Small page is defined as less than or equal to 64KB"
        },
        {
            "code": 33084,
            "refs": [
                0
            ],
            "name": "DTLB_WALK_RW",
            "architectural": false,
            "type": "UEVT",
            "description": "Data TLB demand access with at least one translation table walk"
        },
        {
            "code": 33108,
            "refs": [
                0
            ],
            "name": "L1D_CACHE_HWPRF",
            "architectural": false,
            "type": "UEVT",
            "component": "L1D",
            "description": "Level 1 data cache hardware prefetch"
        },
        {
            "code": 33109,
            "refs": [
                0
            ],
            "name": "L2D_CACHE_HWPRF",
            "architectural": false,
            "type": "UEVT",
            "component": "L2",
            "description": "Level 2 data cache hardware prefetch If the complex is not configured with a per-complex L2 cache, this event counts the cluster cache event, as defined by L3D_CACHE_HWPRF. If neither a per-complex cache or a cluster cache are configured, then this event is not implemented"
        },
        {
            "code": 33110,
            "refs": [
                0
            ],
            "name": "L3D_CACHE_HWPRF",
            "architectural": false,
            "type": "UEVT",
            "component": "L3",
            "description": "Level 3 data cache hardware prefetch If either the complex is configured without a per-complex L2 or the cluster is configured without an L3 cache, this event is not implemented"
        },
        {
            "code": 33112,
            "refs": [
                0
            ],
            "name": "STALL_FRONTEND_MEMBOUND",
            "architectural": false,
            "type": "CYCLE",
            "component": "L1ITLB",
            "description": "Frontend stall cycles, memory bound The counter counts each cycle counted by STALL_FRONTEND when no instructions are delivered from the memory system. This includes the cycles counted by STALL_FRONTEND_L1I, STALL_FRONTEND_MEM and STALL_FRONTEND_TLB"
        },
        {
            "code": 33113,
            "refs": [
                0
            ],
            "name": "STALL_FRONTEND_L1I",
            "architectural": false,
            "type": "CYCLE",
            "component": "L1I",
            "description": "Frontend stall cycles, level 1 instruction cache The counter counts each cycle counted by STALL_FRONTEND_MEMBOUND when there is a demand instruction miss in the L1 instruction cache. If the complex is configured with a per-complex L2 cache, this event does not count if STALL_FRONTEND_MEM counts. If the complex is not configured with a per-complex L2 cache, this event is not implemented"
        },
        {
            "code": 33115,
            "refs": [
                0
            ],
            "name": "STALL_FRONTEND_MEM",
            "architectural": false,
            "type": "CYCLE",
            "component": "L1I",
            "description": "Frontend stall cycles, last level PE cache or memory The counter counts each cycle counted by STALL_FRONTEND_MEMBOUND when there is a demand instruction miss in the last level of cache within the PE clock domain or a noncacheable instruction fetch in progress. If the complex is configured with a per-complex L2 cache, this event is based on L2 cache misses. If the complex is not configured with a per-complex L2 cache, this event is based on L1 instruction cache misses"
        },
        {
            "code": 33116,
            "refs": [
                0
            ],
            "name": "STALL_FRONTEND_TLB",
            "architectural": false,
            "type": "CYCLE",
            "component": "L1ITLB",
            "description": "Frontend stall cycles, TLB The counter counts each cycle counted by STALL_FRONTEND_MEMBOUND when there is a demand instruction miss in the L1 instruction TLB"
        },
        {
            "code": 33120,
            "refs": [
                0
            ],
            "name": "STALL_FRONTEND_CPUBOUND",
            "architectural": false,
            "type": "CYCLE",
            "description": "Frontend stall cycles, processor bound The counter counts each cycle counted by STALL_FRONTEND when the frontend is stalled on a frontend processor resource, not including memory. This includes the cycles counted by STALL_FRONTEND_FLOW and STALL_FRONTEND_FLUSH"
        },
        {
            "code": 33121,
            "refs": [
                0
            ],
            "name": "STALL_FRONTEND_FLOW",
            "architectural": false,
            "type": "CYCLE",
            "component": "BPU",
            "description": "Frontend stall cycles, flow control The counter counts each cycle counted by STALL_FRONTEND_CPUBOUND when the frontend is stalled on unavailability of prediction flow resources"
        },
        {
            "code": 33122,
            "refs": [
                0
            ],
            "name": "STALL_FRONTEND_FLUSH",
            "architectural": false,
            "type": "CYCLE",
            "description": "Frontend stall cycles, flush recovery The counter counts each cycle counted by STALL_FRONTEND_CPUBOUND when the frontend is recovering from a flush"
        },
        {
            "code": 33124,
            "refs": [
                0
            ],
            "name": "STALL_BACKEND_MEMBOUND",
            "architectural": false,
            "type": "CYCLE",
            "component": "L1DTLB",
            "description": "Backend stall cycles, memory bound The counter counts each cycle counted by STALL_BACKEND when the backend is waiting for a memory access to complete. This includes the cycles counted by STALL_BACKEND_L1D, STALL_BACKEND_MEM, STALL_BACKEND_ST and STALL_BACKEND_TLB"
        },
        {
            "code": 33125,
            "refs": [
                0
            ],
            "name": "STALL_BACKEND_L1D",
            "architectural": false,
            "type": "CYCLE",
            "component": "L1D",
            "description": "Backend stall cycles, level 1 data cache The counter counts each cycle counted by STALL_BACKEND_MEMBOUND when there is a demand data miss in the L1 data cache. If the complex is configured with a per-complex L2 cache, this event does not count if STALL_BACKEND_MEM counts. If the complex is not configured with a per-complex L2 cache, this event is not implemented"
        },
        {
            "code": 33127,
            "refs": [
                0
            ],
            "name": "STALL_BACKEND_TLB",
            "architectural": false,
            "type": "CYCLE",
            "component": "L1DTLB",
            "description": "Backend stall cycles, TLB The counter counts each cycle counted by STALL_BACKEND_MEMBOUND when there is a demand data miss in the L1 data TLB"
        },
        {
            "code": 33128,
            "refs": [
                0
            ],
            "name": "STALL_BACKEND_ST",
            "architectural": false,
            "type": "CYCLE",
            "description": "Backend stall cycles, store The counter counts each cycle counted by STALL_BACKEND_MEMBOUND when the backend is stalled waiting for a store"
        },
        {
            "code": 33131,
            "refs": [
                0
            ],
            "name": "STALL_BACKEND_BUSY",
            "architectural": false,
            "type": "CYCLE",
            "description": "Backend stall cycles, backend busy The counter counts each cycle counted by STALL_BACKEND when operations are available from the frontend but the backend is not able to accept an operation because an execution unit is busy"
        },
        {
            "code": 33132,
            "refs": [
                0
            ],
            "name": "STALL_BACKEND_ILOCK",
            "architectural": false,
            "type": "CYCLE",
            "description": "Backend stall cycles, input dependency The counter counts each cycle counted by STALL_BACKEND when operations are available from the frontend but at least one is not ready to be sent to the backend because of an input dependency"
        },
        {
            "code": 33165,
            "refs": [
                0
            ],
            "name": "BUS_REQ_RD",
            "impdef": true,
            "type": "UEVT",
            "component": "BUS",
            "description": "Bus request, read"
        },
        {
            "code": 33212,
            "refs": [
                0
            ],
            "name": "L1D_CACHE_REFILL_HWPRF",
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "subtype": "REFILL",
            "component": "L1D",
            "description": "Level 1 data cache refill, hardware prefetch"
        },
        {
            "code": 33213,
            "refs": [
                0
            ],
            "name": "L2D_CACHE_REFILL_HWPRF",
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "subtype": "REFILL",
            "component": "L2",
            "description": "Level 2 data cache refill, hardware prefetch"
        },
        {
            "code": 33530,
            "refs": [
                0
            ],
            "name": "DTLB_WALK_HWPRF",
            "impdef": true,
            "architectural": false,
            "type": "UEVT",
            "description": "Data TLB access, hardware prefetcher This event counts any access counted by DTLB_WALK that is due to a hardware prefetch"
        }
    ]
}